# RISC-V-Multi Cycle CPU
A multi cycle RISC-V CPU Core using Verilog

## Abstract
This paper explores the design and implementation of a multi-cycle CPU based on the RISC-V instruction set architecture. Multi-cycle CPUs offer a balance between performance and complexity, making them a compelling choice for various computing applications. Leveraging the simplicity and efficiency of the RISC-V instruction set, our design aims to optimize critical path length while ensuring efficient execution of instructions. Through detailed analysis and simulation, we evaluate the performance and efficiency of the proposed multi-cycle CPU architecture. Our findings underscore the viability and effectiveness of RISC-V in facilitating the development of high-performance processors for diverse computing environments.

![image](https://raw.githubusercontent.com/vanngo411/MultiCycle_CPU_RISCV/main/Block%20Diagram.png)

## Final datapath in Quartus Prime

The RICSV_TOP module encapsulates a comprehensive datapath and control unit for a RISC-V processor implementation. The datapath includes essential elements such as a Register File, ALU, Instruction Memory, and Data Memory, all meticulously interconnected to facilitate the execution of instructions. The Register File serves as the primary storage for operands and results of arithmetic and logical operations, with data routed through multiplexers for dynamic selection of input sources. The ALU, guided by dynamically generated control signals derived from the Control module, performs various arithmetic and logical operations on operands fetched from the Register File or immediate values generated by the Immediate Generator module. Furthermore, the Instruction Memory module retrieves instructions based on the program counter value, ensuring seamless instruction fetching. Data Memory handles data transfers between the processor and external memory, supporting both read and write operations as dictated by control signals. The control unit orchestrates the sequencing of instructions by interpreting opcode fields and generating control signals to govern the behavior of the datapath components. Additionally, hazard detection mechanisms are employed to identify and resolve potential data hazards, maintaining the correctness of instruction execution within the pipeline. Through careful integration and coordination of these components, the RICSV_TOP module embodies a robust multi-cycle CPU design tailored for the RISC-V architecture, offering efficient and reliable execution of instructions.

Within the RICSV_TOP module, the forwarding module plays a critical role in enhancing the efficiency of instruction execution by enabling data forwarding between pipeline stages. This module is designed to detect data dependencies and provide the necessary data to instructions in subsequent stages of the pipeline, thereby mitigating stalls and improving throughput. By monitoring the register destinations of instructions in flight and comparing them to the register sources of instructions currently in execution, the forwarding module determines if forwarding is required. Through dynamic selection of data sources using multiplexers, the forwarding module ensures that instructions receive the most up-to-date data available, optimizing performance without sacrificing correctness.

Conversely, the hazard detection module serves as a safeguard against potential hazards that could disrupt the orderly execution of instructions. It detects hazards arising from dependencies between instructions, such as data hazards and control hazards, and takes appropriate actions to resolve them. Data hazards occur when instructions depend on data produced by preceding instructions that have not yet completed execution. In such cases, the hazard detection module stalls the pipeline or initiates forwarding to ensure that instructions receive the correct data. Control hazards arise from branch instructions that alter the program counter, potentially causing incorrect instruction fetching. The hazard detection module detects these hazards and manages the control flow to maintain program correctness. By identifying and addressing hazards in real-time, the hazard detection module ensures smooth and uninterrupted execution of instructions within the RICSV_TOP module, contributing to overall system reliability and efficiency.

![image](https://github.com/vanngo411/MultiCycle_CPU_RISCV/blob/main/DataAndControlPath.png)

## ModelSim Output Waveform
![image](https://github.com/vanngo411/MultiCycle_CPU_RISCV/blob/main/ForwardingTest.png)

In the first test case, we execute an "add" instruction to add the value in register x25 to itself and store the result in register x10. This operation is followed immediately by another identical "add" instruction. Since the result of the first instruction is not yet written back to register x10, the forwarding module detects the data dependency and forwards the result directly from the ALU output of the first instruction to the ALU input of the second instruction. As a result, the second instruction can execute without waiting for the write-back stage of the first instruction, leading to efficient execution. The total value of x15 is 200 and is the same with result that write back to register in testing.

![image](https://github.com/vanngo411/MultiCycle_CPU_RISCV/blob/main/HazardDetectionTest.png)

In the second test case, we execute an "lw" (load word) instruction to load a value from memory into register x2, followed by an "add" instruction to add the value in register x5 to the value in register x10 and store the result in register x10. Again, the forwarding module detects the data dependency between the "lw" instruction and the subsequent "add" instruction and forwards the correct data to the ALU input of the "add" instruction, allowing it to execute without stalling. This efficient handling of data dependencies results in smooth instruction execution and improved performance.  The hazard detection module ensures proper sequencing of instructions despite the data dependencies between the "lw" and "add" instructions. By detecting the dependency and stalling the subsequent instruction until the data is available, the hazard detection module guarantees the correctness of instruction execution. If we take a look on PC cycle number 12 (after 16 PC), all output of Rs1, Rs2 and Rd are zero, it means this CPU is used a nop instead of add instruction because it detects a hazard. The program will try to re load the instruction 16 again at PC number 16 to make sure having a right result is 28.

